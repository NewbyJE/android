diff --git a/minui/Android.mk b/minui/Android.mk
index 691f84c..ac71969 100644
--- a/minui/Android.mk
+++ b/minui/Android.mk
@@ -11,7 +11,7 @@ common_c_includes := \
 ifeq ($(call is-vendor-board-platform,QCOM),true)
   common_additional_dependencies := $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr
   common_c_includes += $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr/include
-  common_src_files += graphics_overlay.c vsync.c
+  common_src_files += graphics_overlay.c
   common_cflags += -DMSMFB_OVERLAY
 endif
 
diff --git a/minui/graphics_overlay.c b/minui/graphics_overlay.c
index 2d968e8..4490b77 100644
--- a/minui/graphics_overlay.c
+++ b/minui/graphics_overlay.c
@@ -1,6 +1,5 @@
 /*
  * Copyright (c) 2013, The Linux Foundation. All rights reserved.
- * Copyright (c) 2014, The CyanogenMod Project
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are
@@ -48,7 +47,6 @@
 
 #include "minui.h"
 #include "graphics.h"
-#include "vsync.h"
 
 #ifdef MDSS_MDP_RIGHT_MIXER
 
@@ -82,14 +80,10 @@ typedef struct {
     int offset;
 } ion_mem_info;
 
-// double buffer
-#define NUM_BUFFERS 2
-static ion_mem_info mem_info[NUM_BUFFERS];
-static int cur_buf = 0;
-
 //Left and right overlay id
 static int overlayL_id = MSMFB_NEW_REQUEST;
 static int overlayR_id = MSMFB_NEW_REQUEST;
+static ion_mem_info mem_info;
 static bool isMDP5 = false;
 
 static int map_mdp_pixel_format()
@@ -200,85 +194,75 @@ static bool isTargetMdp5() {
 }
 
 static int free_ion_mem(void) {
-    int ret = 0, i = 0;
+    int ret = 0;
 
-    for (i = 0; i < NUM_BUFFERS; i++) {
-        if (mem_info[i].mem_buf)
-            munmap(mem_info[i].mem_buf, mem_info[i].size);
+    if (mem_info.mem_buf)
+        munmap(mem_info.mem_buf, mem_info.size);
 
-        if (mem_info[i].ion_fd >= 0) {
-            ret = ioctl(mem_info[i].ion_fd, ION_IOC_FREE, &mem_info[i].handle_data);
-            if (ret < 0) {
-                perror("free_mem failed ");
-                continue;
-            }
-        }
+    if (mem_info.ion_fd >= 0) {
+        ret = ioctl(mem_info.ion_fd, ION_IOC_FREE, &mem_info.handle_data);
+        if (ret < 0)
+            perror("free_mem failed ");
+    }
 
-        if (mem_info[i].mem_fd >= 0)
-            close(mem_info[i].mem_fd);
-        if (mem_info[i].ion_fd >= 0)
-            close(mem_info[i].ion_fd);
+    if (mem_info.mem_fd >= 0)
+        close(mem_info.mem_fd);
+    if (mem_info.ion_fd >= 0)
+        close(mem_info.ion_fd);
 
-        memset(&mem_info[i], 0, sizeof(ion_mem_info));
-        mem_info[i].mem_fd = -1;
-        mem_info[i].ion_fd = -1;
-    }
+    memset(&mem_info, 0, sizeof(mem_info));
+    mem_info.mem_fd = -1;
+    mem_info.ion_fd = -1;
     return 0;
 }
 
 static int alloc_ion_mem(unsigned int size)
 {
-    int result = 0, i = 0;
+    int result;
     struct ion_fd_data fd_data;
     struct ion_allocation_data ionAllocData;
 
+    mem_info.ion_fd = open("/dev/ion", O_RDWR|O_DSYNC);
+    if (mem_info.ion_fd < 0) {
+        perror("ERROR: Can't open ion ");
+        return -errno;
+    }
+
     ionAllocData.flags = 0;
-    ionAllocData.len = size;
+    ionAllocData.len = size * 2; // double buffer
     ionAllocData.align = sysconf(_SC_PAGESIZE);
     ionAllocData.heap_mask =
             ION_HEAP(ION_IOMMU_HEAP_ID) |
             ION_HEAP(ION_SYSTEM_HEAP_ID);
 
-    for (i = 0; i < NUM_BUFFERS; i++) {
-        mem_info[i].ion_fd = open("/dev/ion", O_RDWR|O_DSYNC);
-        if (mem_info[i].ion_fd < 0) {
-            perror("ERROR: Can't open ion ");
-            return -errno;
-        }
-
-        printf("%s: ion_fd=%d\n", __func__, mem_info[i].ion_fd);
-
-        result = ioctl(mem_info[i].ion_fd, ION_IOC_ALLOC,  &ionAllocData);
-        if(result){
-            perror("ION_IOC_ALLOC Failed ");
-            close(mem_info[i].ion_fd);
-            return result;
-        }
+    result = ioctl(mem_info.ion_fd, ION_IOC_ALLOC,  &ionAllocData);
+    if(result){
+        perror("ION_IOC_ALLOC Failed ");
+        close(mem_info.ion_fd);
+        return result;
+    }
 
-        fd_data.handle = ionAllocData.handle;
-        mem_info[i].handle_data.handle = ionAllocData.handle;
-        result = ioctl(mem_info[i].ion_fd, ION_IOC_MAP, &fd_data);
-        if (result) {
-            perror("ION_IOC_MAP Failed ");
-            free_ion_mem();
-            return result;
-        }
-        mem_info[i].mem_buf = (unsigned char *)mmap(NULL, size, PROT_READ |
-                    PROT_WRITE, MAP_SHARED, fd_data.fd, 0);
-        mem_info[i].mem_fd = fd_data.fd;
-
-        if (mem_info[i].mem_buf == MAP_FAILED) {
-            perror("ERROR: ION MAP_FAILED ");
-            mem_info[i].mem_buf = NULL;
-            free_ion_mem();
-            return -ENOMEM;
-        }
+    fd_data.handle = ionAllocData.handle;
+    mem_info.handle_data.handle = ionAllocData.handle;
+    result = ioctl(mem_info.ion_fd, ION_IOC_MAP, &fd_data);
+    if (result) {
+        perror("ION_IOC_MAP Failed ");
+        free_ion_mem();
+        return result;
+    }
+    mem_info.mem_buf = (unsigned char *)mmap(NULL, size * 2, PROT_READ |
+                PROT_WRITE, MAP_SHARED, fd_data.fd, 0);
+    mem_info.mem_fd = fd_data.fd;
 
-        printf("%s: ion_fd=%d mem_fd=%d buf=%p\n", __func__, mem_info[i].ion_fd,
-                mem_info[i].mem_fd, mem_info[i].mem_buf);
-        mem_info[i].offset = 0;
+    if (mem_info.mem_buf == MAP_FAILED) {
+        perror("ERROR: ION MAP_FAILED ");
+        mem_info.mem_buf = NULL;
+        free_ion_mem();
+        return -ENOMEM;
     }
 
+    mem_info.offset = 0;
+
     return 0;
 }
 
@@ -306,7 +290,7 @@ static int allocate_overlay(int fd)
             overlayL.id = MSMFB_NEW_REQUEST;
             ret = ioctl(fd, MSMFB_OVERLAY_SET, &overlayL);
             if (ret < 0) {
-                perror("Overlay Set Failed \n");
+                perror("Overlay Set Failed");
                 return ret;
             }
             overlayL_id = overlayL.id;
@@ -417,6 +401,7 @@ static int free_overlay(int fd)
     }
     memset(&ext_commit, 0, sizeof(struct mdp_display_commit));
     ext_commit.flags = MDP_DISPLAY_COMMIT_OVERLAY;
+    ext_commit.wait_for_finish = 1;
     ret = ioctl(fd, MSMFB_DISPLAY_COMMIT, &ext_commit);
     if (ret < 0) {
         perror("ERROR: Clear MSMFB_DISPLAY_COMMIT failed!");
@@ -446,9 +431,8 @@ static int overlay_display_frame(int fd, size_t size)
 
         ovdataL.id = overlayL_id;
         ovdataL.data.flags = 0;
-        ovdataL.data.offset = mem_info[cur_buf].offset;
-        ovdataL.data.memory_id = mem_info[cur_buf].mem_fd;
-
+        ovdataL.data.offset = mem_info.offset;
+        ovdataL.data.memory_id = mem_info.mem_fd;
         ret = ioctl(fd, MSMFB_OVERLAY_PLAY, &ovdataL);
         if (ret < 0) {
             perror("overlay_display_frame failed, overlay play Failed\n");
@@ -465,9 +449,8 @@ static int overlay_display_frame(int fd, size_t size)
 
         ovdataL.id = overlayL_id;
         ovdataL.data.flags = 0;
-        ovdataL.data.offset = mem_info[cur_buf].offset;
-        ovdataL.data.memory_id = mem_info[cur_buf].mem_fd;
-
+        ovdataL.data.offset = mem_info.offset;
+        ovdataL.data.memory_id = mem_info.mem_fd;
         ret = ioctl(fd, MSMFB_OVERLAY_PLAY, &ovdataL);
         if (ret < 0) {
             perror("overlay_display_frame failed, overlayL play Failed\n");
@@ -483,28 +466,25 @@ static int overlay_display_frame(int fd, size_t size)
 
         ovdataR.id = overlayR_id;
         ovdataR.data.flags = 0;
-        ovdataR.data.offset = mem_info[cur_buf].offset;
-        ovdataR.data.memory_id = mem_info[cur_buf].mem_fd;
+        ovdataR.data.offset = mem_info.offset;
+        ovdataR.data.memory_id = mem_info.mem_fd;
         ret = ioctl(fd, MSMFB_OVERLAY_PLAY, &ovdataR);
         if (ret < 0) {
             perror("overlay_display_frame failed, overlayR play Failed\n");
             return ret;
         }
     }
-
     memset(&ext_commit, 0, sizeof(struct mdp_display_commit));
     ext_commit.flags = MDP_DISPLAY_COMMIT_OVERLAY;
+    ext_commit.wait_for_finish = 1;
     ret = ioctl(fd, MSMFB_DISPLAY_COMMIT, &ext_commit);
     if (ret < 0) {
         perror("overlay_display_frame failed, overlay commit Failed\n!");
-        goto done;
     }
 
-    // swap to next buffer
-    cur_buf ^= 1;
-    gr_draw.data = mem_info[cur_buf].mem_buf;
+    mem_info.offset ^= size;
+    gr_draw.data = mem_info.mem_buf + mem_info.offset;
 
-done:
     return ret;
 }
 
@@ -565,16 +545,12 @@ static gr_surface overlay_init(minui_backend* backend)
         return NULL;
     }
 
-    vsync_init(fd);
-
-    gr_draw.data = mem_info[cur_buf].mem_buf;
+    gr_draw.data = mem_info.mem_buf;
     return &gr_draw;
 }
 
 static gr_surface overlay_flip(minui_backend* backend __unused)
 {
-    wait_for_vsync();
-
     if (overlay_display_frame(fb_fd, (gr_draw.row_bytes * gr_draw.height)) < 0) {
         // Free and allocate overlay in failure case
         // so that next cycle can be retried
diff --git a/minui/vsync.c b/minui/vsync.c
deleted file mode 100644
index c2f536a..0000000
--- a/minui/vsync.c
+++ /dev/null
@@ -1,158 +0,0 @@
-/*
- * Copyright (c) 2014, The CyanogenMod Project
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include <stdbool.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <poll.h>
-#include <pthread.h>
-#include <time.h>
-
-#include <linux/ioctl.h>
-#include <linux/msm_mdp.h>
-
-#define FB_NUM 0
-#define VSYNC_PREFIX "VSYNC="
-#define VSYNC_TIMEOUT_NS (60000 * 1000)
-
-static pthread_cond_t vsync;
-static pthread_mutex_t vsync_lock = PTHREAD_MUTEX_INITIALIZER;
-static int vsync_enabled = 0;
-static struct timespec vsync_time;
-
-static int fb_fd = -1;
-
-static int vsync_control(int enable)
-{
-    int ret = 0;
-
-    // save the time so we can turn off the interrupt when idle
-    clock_gettime(CLOCK_REALTIME, &vsync_time);
-
-    if (vsync_enabled != enable) {
-        if (fb_fd <= 0 || ioctl(fb_fd, MSMFB_OVERLAY_VSYNC_CTRL, &enable) < 0) {
-            perror("vsync control failed!");
-            ret = -errno;
-        } else {
-            vsync_enabled = enable;
-        }
-    }
-
-    return ret;
-}
-
-static void *vsync_loop(void *data)
-{
-    char vsync_node_path[255];
-    char vdata[64];
-    int fd = -1;
-    int err = 0, len = 0;
-    struct timespec now;
-    struct pollfd pfd;
-
-    snprintf(vsync_node_path, sizeof(vsync_node_path),
-            "/sys/class/graphics/fb%d/vsync_event", 0);
-    fd = open(vsync_node_path, O_RDONLY);
-
-    if (fd < 0) {
-        perror("unable to initialize vsync\n");
-        return NULL;
-    }
-
-    pread(fd, vdata, 64, 0);
-    pfd.fd = fd;
-    pfd.events = POLLPRI | POLLERR;
-
-    printf("%s: vsync thread started\n", __func__);
-
-    // loop forever until sysfs wakes us up
-    while (true) {
-        err = poll(&pfd, 1, -1);
-
-        if (pfd.revents & POLLPRI) {
-            len = pread(pfd.fd, vdata, 64, 0);
-            if (len > 0) {
-                // notify waiters
-                if (!strncmp(vdata, VSYNC_PREFIX, strlen(VSYNC_PREFIX))) {
-                    pthread_cond_signal(&vsync);
-                }
-            } else {
-                perror("unable to read vsync timestamp!\n");
-            }
-        }
-
-        // turn of the interrupt when we're not drawing
-        clock_gettime(CLOCK_REALTIME, &now);
-
-        if ((now.tv_nsec - vsync_time.tv_nsec) > VSYNC_TIMEOUT_NS) {
-            vsync_control(0);
-        }
-    }
-}
-
-void wait_for_vsync()
-{
-    static struct timespec ts;
-    static struct timeval now;
-    int ret = 0;
-
-    vsync_control(1);
-
-    gettimeofday(&now, NULL);
-    ts.tv_sec = now.tv_sec;
-    ts.tv_nsec = (now.tv_usec * 1000) + (20 * 1000 * 1000);
-
-    // vsync_loop will let us know when to proceed
-    pthread_mutex_lock(&vsync_lock);
-    pthread_cond_timedwait(&vsync, &vsync_lock, &ts);
-    pthread_mutex_unlock(&vsync_lock);
-}
-
-int vsync_init(int fd)
-{
-    pthread_t vsync_thread;
-    int ret = 0;
-
-    fb_fd = fd;
-
-    pthread_mutex_init(&vsync_lock, NULL);
-    pthread_cond_init(&vsync, NULL);
-
-    ret = pthread_create(&vsync_thread, NULL, vsync_loop, NULL);
-
-    if (ret != 0) {
-        perror("failed to create vsync thread!");
-    }
-
-    return ret;
-}
-
diff --git a/minui/vsync.h b/minui/vsync.h
deleted file mode 100644
index b14edd8..0000000
--- a/minui/vsync.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (c) 2014, The CyanogenMod Project
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-void wait_for_vsync(void);
-
-int vsync_init(int fd);
diff --git a/screen_ui.cpp b/screen_ui.cpp
index 1555c80..3476d25 100644
--- a/screen_ui.cpp
+++ b/screen_ui.cpp
@@ -366,7 +366,7 @@ void ScreenRecoveryUI::update_screen_locked()
 // Should only be called with updateMutex locked.
 void ScreenRecoveryUI::update_progress_locked()
 {
-    if (!pagesIdentical) {
+    if (show_text || !pagesIdentical) {
         draw_screen_locked();    // Must redraw the whole screen
         pagesIdentical = true;
     } else {
@@ -392,7 +392,7 @@ void ScreenRecoveryUI::progress_loop() {
         // update the installation animation, if active
         // skip this if we have a text overlay (too expensive to update)
         if ((currentIcon == INSTALLING_UPDATE || currentIcon == ERASING) &&
-            installing_frames > 0) {
+            installing_frames > 0 && !show_text) {
             installingFrame = (installingFrame + 1) % installing_frames;
             redraw = 1;
         }
@@ -412,16 +412,11 @@ void ScreenRecoveryUI::progress_loop() {
         if (redraw) update_progress_locked();
 
         pthread_mutex_unlock(&updateMutex);
-
-        if (progressBarType == EMPTY)
-            break;
-
         double end = now();
         // minimum of 20ms delay between frames
         double delay = interval - (end-start);
         if (delay < 0.02) delay = 0.02;
         usleep((long)(delay * 1000000));
-
     }
 }
 
@@ -494,6 +489,8 @@ void ScreenRecoveryUI::Init()
     LoadLocalizedBitmap("no_command_text", &backgroundText[NO_COMMAND]);
     LoadLocalizedBitmap("error_text", &backgroundText[ERROR]);
 
+    pthread_create(&progress_t, NULL, progress_thread, NULL);
+
     RecoveryUI::Init();
 }
 
@@ -551,9 +548,6 @@ void ScreenRecoveryUI::SetProgressType(ProgressType type)
     pthread_mutex_lock(&updateMutex);
     if (progressBarType != type) {
         progressBarType = type;
-        if (progressBarType != EMPTY) {
-            pthread_create(&progress_t, NULL, progress_thread, NULL);
-        }
     }
     progressScopeStart = 0;
     progressScopeSize = 0;
