diff --git a/src/drivers/driver_nl80211.c b/src/drivers/driver_nl80211.c
index dc87438..4034f20 100644
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -58,9 +58,12 @@
 #define PACKET_TX_TIMESTAMP	16
 #endif
 
+#define MAX_WPSP2PIE_CMD_SIZE		512
+
 #ifdef ANDROID
 #include "android_drv.h"
 #endif /* ANDROID */
+
 #ifdef CONFIG_LIBNL20
 /* libnl 2.0 compatibility code */
 #define nl_handle nl_sock
@@ -9142,12 +9145,10 @@ static int wpa_driver_nl80211_driver_cmd(void *priv, char *cmd, char *buf,
         } else if (os_strcasecmp(cmd, "MACADDR") == 0) {
                 u8 macaddr[ETH_ALEN] = {};
 
-                ret = linux_get_ifhwaddr(drv->global->ioctl_sock, bss->ifname,
-                                         macaddr);
+                ret = linux_get_ifhwaddr(drv->global->ioctl_sock, bss->ifname, macaddr);
                 if (!ret)
                         ret = os_snprintf(buf, buf_len,
-                                          "Macaddr = " MACSTR "\n",
-                                          MAC2STR(macaddr));
+                                          "Macaddr = " MACSTR "\n", MAC2STR(macaddr));
         } else if (os_strcasecmp(cmd, "RELOAD") == 0) {
                 wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
         } else if (os_strncasecmp(cmd, "POWERMODE ", 10) == 0) {
@@ -9163,10 +9164,56 @@ static int wpa_driver_nl80211_driver_cmd(void *priv, char *cmd, char *buf,
                 if (!ret && (state != -1))
                         ret = os_snprintf(buf, buf_len, "POWERMODE = %d\n",
                                           state);
+        } else if(os_strcmp(cmd, "SCAN-ACTIVE") == 0) {
+                return 0; /* unsupported function */
+        } else if(os_strcmp(cmd, "SCAN-PASSIVE") == 0) {
+                return 0; /* unsupported function */
+        } else if(os_strncmp(cmd, "RXFILTER-ADD ", 13) == 0) {
+                return 0; /* Ignore it */
+        } else if(os_strncmp(cmd, "RXFILTER-REMOVE ", 16) == 0) {
+                return 0; /* Ignore it */
+        } else if(os_strncmp(cmd, "COUNTRY ", 8) == 0) {
+                return 0; /* Ignore it */
+        } else if(os_strncmp(cmd, "SETBAND ", 8) == 0) {
+                return 0; /* Ignore it */
+        } else if(os_strncmp(cmd, "SETSUSPENDMODE ", 15) == 0) {
+                return 0; /* Ignore it */
+        } else if(os_strncmp(cmd, "WLS_BATCHING ", 13) == 0) {
+                return 0; /* Ignore it */
+        } else if(os_strncmp(cmd, "BTCOEXSCAN-START", 16) == 0) {
+                return 0; /* Ignore it */
+        } else if(os_strncmp(cmd, "BTCOEXSCAN-STOP", 15) == 0) {
+                return 0; /* Ignore it */
+	} else if(os_strncmp(cmd, "BTCOEXMODE ", 11) == 0) {
+                int mode;
+                if (sscanf(cmd, "%*s %d", &mode)==1) {
+                        /*
+                         * Android disable BT-COEX when obtaining dhcp packet except there is headset is connected
+                         * It enable the BT-COEX after dhcp process is finished
+                         * We ignore since we have our way to do bt-coex during dhcp obtaining.
+                         */
+                        switch (mode) {
+                        case 1: /* Disable*/
+                                break;
+                        case 0: /* Enable */
+                                /* fall through */
+                        case 2: /* Sense*/
+                                /* fall through */
+                        default:
+                                break;
+                        }
+                        return 0; /* ignore it */
+                }
+        } else if(os_strcmp(cmd, "RXFILTER-START") == 0) {
+                // STUB
+                return 0;
+        } else if(os_strcmp(cmd, "RXFILTER-STOP") == 0) {
+                // STUB
+                return 0;
         } else { /* Use private command */
+                os_memcpy(buf, cmd, strlen(cmd) + 1);
                 memset(&ifr, 0, sizeof(ifr));
                 memset(&priv_cmd, 0, sizeof(priv_cmd));
-                os_memcpy(buf, cmd, strlen(cmd) + 1);
                 os_strncpy(ifr.ifr_name, bss->ifname, IFNAMSIZ);
 
                 priv_cmd.buf = buf;
@@ -9174,11 +9221,17 @@ static int wpa_driver_nl80211_driver_cmd(void *priv, char *cmd, char *buf,
                 priv_cmd.total_len = buf_len;
                 ifr.ifr_data = &priv_cmd;
 
-	if ((ret = ioctl(drv->global->ioctl_sock, SIOCDEVPRIVATE + 1, &ifr)) < 0) {
-                        wpa_printf(MSG_DEBUG, "%s: failed to issue private commands\n", __func__);
+        if ((ret = ioctl(drv->global->ioctl_sock, SIOCDEVPRIVATE + 1, &ifr)) < 0) {
+               wpa_printf(MSG_ERROR, "%s: failed to issue private commands (CMD=%s)\n", __func__, cmd);
+               wpa_driver_send_hang_msg(drv);
                 } else {
+                        drv_errors = 0;
                         ret = 0;
-                        if (os_strncasecmp(cmd, "SETBAND", 7) == 0) {
+                        if ((os_strcasecmp(cmd, "LINKSPEED") == 0) ||
+				(os_strcasecmp(cmd, "RSSI") == 0) ||
+				(os_strcasecmp(cmd, "GETBAND") == 0) ) {
+				ret = strlen(buf);
+                        } else if (os_strncasecmp(cmd, "SETBAND", 7) == 0) {
                                 wpa_printf(MSG_DEBUG, "%s: %s ", __func__, cmd);
                         } else if (os_strcasecmp(cmd, "P2P_DEV_ADDR") == 0) {
                                 wpa_printf(MSG_DEBUG, "%s: P2P: Device address ("MACSTR")",
@@ -9187,7 +9240,10 @@ static int wpa_driver_nl80211_driver_cmd(void *priv, char *cmd, char *buf,
                                 wpa_printf(MSG_DEBUG, "%s: P2P: %s ", __func__, buf);
                         } else if (os_strcasecmp(cmd, "P2P_SET_NOA") == 0) {
                                 wpa_printf(MSG_DEBUG, "%s: P2P: %s ", __func__, buf);
-                        }
+                        } else if (os_strncasecmp(cmd, "COUNTRY", 7) == 0) {
+                                wpa_supplicant_event(drv->ctx, EVENT_CHANNEL_LIST_CHANGED, NULL);
+                       }
+                       wpa_printf(MSG_DEBUG, "%s %s len = %d, %d", __func__, buf, ret, strlen(buf));
                 }
         }
 
@@ -9197,26 +9253,71 @@ static int wpa_driver_nl80211_driver_cmd(void *priv, char *cmd, char *buf,
 
 #ifdef ANDROID_QCOM_PATCH
 #ifdef ANDROID_P2P
-static int wpa_driver_set_p2p_noa(void *priv, u8 count, int start,
-				  int duration)
+static int wpa_driver_set_p2p_noa(void *priv, u8 count, int start, int duration)
 {
-	char buf[MAX_DRV_CMD_SIZE];
+        char buf[MAX_DRV_CMD_SIZE];
 
-	memset(buf, 0, sizeof(buf));
-	wpa_printf(MSG_DEBUG, "%s: Entry", __func__);
-	os_snprintf(buf, sizeof(buf), "P2P_SET_NOA %d %d %d", count, start,
-		    duration);
-	return wpa_driver_nl80211_driver_cmd(priv, buf, buf, strlen(buf) + 1);
+        memset(buf, 0, sizeof(buf));
+        wpa_printf(MSG_DEBUG, "%s: Entry", __func__);
+        os_snprintf(buf, sizeof(buf), "P2P_SET_NOA %d %d %d", count, start, duration);
+        return wpa_driver_nl80211_driver_cmd(priv, buf, buf, strlen(buf) + 1);
+}
+
+static int wpa_driver_get_p2p_noa(void *priv, u8 *buf, size_t len)
+{
+        /* Return 0 till we handle p2p_presence request completely in the driver */
+        return 0;
 }
 
 static int wpa_driver_set_p2p_ps(void *priv, int legacy_ps, int opp_ps, int ctwindow)
 {
-	char buf[MAX_DRV_CMD_SIZE];
+        char buf[MAX_DRV_CMD_SIZE];
+
+        memset(buf, 0, sizeof(buf));
+        wpa_printf(MSG_DEBUG, "%s: Entry", __func__);
+        snprintf(buf, sizeof(buf), "P2P_SET_PS %d %d %d", legacy_ps, opp_ps, ctwindow);
+        return wpa_driver_nl80211_driver_cmd(priv, buf, buf, strlen(buf) + 1);
+}
+
+static int wpa_driver_set_ap_wps_p2p_ie(void *priv, const struct wpabuf *beacon,
+                                 const struct wpabuf *proberesp,
+                                 const struct wpabuf *assocresp)
+{
+        char buf[MAX_WPSP2PIE_CMD_SIZE];
+        struct wpabuf *ap_wps_p2p_ie = NULL;
+        char *_cmd = "SET_AP_WPS_P2P_IE";
+        char *pbuf;
+        int ret = 0;
+        int i;
+        struct cmd_desc {
+                int cmd;
+                const struct wpabuf *src;
+        } cmd_arr[] = {
+                {0x1, beacon},
+                {0x2, proberesp},
+                {0x4, assocresp},
+                {-1, NULL}
+        };
+
+        wpa_printf(MSG_DEBUG, "%s: Entry", __func__);
+        for (i = 0; cmd_arr[i].cmd != -1; i++) {
+                os_memset(buf, 0, sizeof(buf));
+                pbuf = buf;
+                pbuf += sprintf(pbuf, "%s %d", _cmd, cmd_arr[i].cmd);
+                *pbuf++ = '\0';
+                ap_wps_p2p_ie = cmd_arr[i].src ?
+                        wpabuf_dup(cmd_arr[i].src) : NULL;
+                if (ap_wps_p2p_ie) {
+                        os_memcpy(pbuf, wpabuf_head(ap_wps_p2p_ie), wpabuf_len(ap_wps_p2p_ie));
+                        ret = wpa_driver_nl80211_driver_cmd(priv, buf, buf,
+                                strlen(_cmd) + 3 + wpabuf_len(ap_wps_p2p_ie));
+                        wpabuf_free(ap_wps_p2p_ie);
+                        if (ret < 0)
+                                break;
+                }
+        }
 
-	memset(buf, 0, sizeof(buf));
-	wpa_printf(MSG_DEBUG, "%s: Entry", __func__);
-	snprintf(buf, sizeof(buf), "P2P_SET_PS %d %d %d", legacy_ps, opp_ps, ctwindow);
-	return wpa_driver_nl80211_driver_cmd(priv, buf, buf, strlen(buf) + 1);
+        return ret;
 }
 #endif /* ANDROID_P2P */
 #endif /* ANDROID_QCOM_PATCH */
